<!doctype html>
<html lang="lt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TopShop Deals – Space Runner</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <style>
    body{ overflow:hidden; }
    .hud{
      display:flex; justify-content:space-between; align-items:center;
      gap: 12px; padding: 10px 6px 12px; flex-wrap: wrap;
      color: rgba(255,255,255,.80); font-size: 14px;
    }
    .hud b{ color: rgba(255,255,255,.96); }
    .hud .left{ display:flex; gap: 16px; flex-wrap: wrap; align-items:center; }
    .hud .right{ display:flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    .mini{
      padding: 10px 14px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color: rgba(255,255,255,.92);
      text-decoration:none; font-weight: 900; cursor:pointer;
    }
    .mini:hover{ filter: brightness(1.10); }
    #game{
      width: 100%;
      height: min(600px, 72vh);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      display:block;
      touch-action: manipulation;
    }
    .hint{
      margin-top: 10px; color: rgba(255,255,255,.62);
      font-size: 12px; text-align:left;
    }
  </style>
</head>
<body>
  <canvas id="snow" aria-hidden="true"></canvas>

  <main class="center" style="z-index:1;">
    <section class="card" style="padding:18px; text-align:left;">
      <div class="hud">
        <div class="left">
          <div>Score: <b id="score">0</b></div>
          <div>Best: <b id="best">0</b></div>
          <div>Status: <b id="status">Ready</b></div>
        </div>
        <div class="right">
          <button class="mini" id="start" type="button">Start</button>
          <button class="mini" id="restart" type="button">Restart</button>
          <a class="mini" href="/">Atgal</a>
        </div>
      </div>

      <canvas id="game"></canvas>
      <div class="hint">
        Valdymas: <b>Space</b> / <b>Click</b> / <b>Tap</b> — “šoktelėk”. Skrisk pro tarpus, neliesk sienų.
      </div>
    </section>
  </main>

  <script>
    // ---------- Background snow ----------
    const snow = document.getElementById("snow");
    const sctx = snow.getContext("2d");
    let SW=0, SH=0, sflakes=[];

    function sresize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      snow.width = Math.floor(window.innerWidth * dpr);
      snow.height = Math.floor(window.innerHeight * dpr);
      snow.style.width = window.innerWidth + "px";
      snow.style.height = window.innerHeight + "px";
      sctx.setTransform(dpr,0,0,dpr,0,0);
      SW = window.innerWidth; SH = window.innerHeight;
      const count = Math.floor((SW*SH)/18000);
      sflakes = Array.from({length:count}, ()=>({
        x: Math.random()*SW,
        y: Math.random()*SH,
        r: 0.8+Math.random()*2.0,
        vy: 0.5+Math.random()*1.1,
        a: 0.14+Math.random()*0.32
      }));
    }
    function sdraw(){
      const g = sctx.createLinearGradient(0,0,SW,SH);
      g.addColorStop(0,"#071c3e");
      g.addColorStop(1,"#02040c");
      sctx.fillStyle=g; sctx.fillRect(0,0,SW,SH);

      const glow = sctx.createRadialGradient(SW*0.18, SH*0.25, 0, SW*0.18, SH*0.25, Math.max(SW,SH)*0.6);
      glow.addColorStop(0, "rgba(60,130,255,0.16)");
      glow.addColorStop(1, "rgba(60,130,255,0)");
      sctx.fillStyle = glow;
      sctx.fillRect(0,0,SW,SH);

      for(const f of sflakes){
        f.y += f.vy;
        if(f.y>SH+10){ f.y = -10; f.x = Math.random()*SW; }
        sctx.beginPath();
        sctx.fillStyle = `rgba(255,255,255,${f.a})`;
        sctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        sctx.fill();
      }
      requestAnimationFrame(sdraw);
    }
    window.addEventListener("resize", sresize);
    sresize(); requestAnimationFrame(sdraw);

    // ---------- Space Runner ----------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const statusEl = document.getElementById("status");

    let W=0, H=0, DPR=1;

    // Safe resize: ensure canvas has layout first
    function resizeGame(){
      const rect = canvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return false;

      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(rect.width * DPR);
      canvas.height = Math.floor(rect.height * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);

      W = rect.width; H = rect.height;
      ship.x = W * 0.28;
      ship.y = Math.min(Math.max(ship.y || H*0.5, ship.r+4), H-ship.r-4);
      return true;
    }

    // Game state
    let running = false;
    let dead = false;
    let score = 0;

    let best = Number(localStorage.getItem("bestSpaceRunner") || "0");
    bestEl.textContent = best;

    const ship = { x: 0, y: 0, r: 14, vy: 0 };

    // physics in "per second"
    const gravity = 1800;  // px/s^2
    const jumpV   = -520;  // px/s

    let pipes = [];
    let spawnAcc = 0;

    function reset(){
      running = false;
      dead = false;
      score = 0;
      pipes = [];
      spawnAcc = 0;
      ship.vy = 0;

      scoreEl.textContent = score;
      statusEl.textContent = "Ready";

      if (W && H) ship.y = H*0.5;
    }

    function start(){
      if (running) return;
      running = true;
      dead = false;
      statusEl.textContent = "Go!";

      // ensure we have pipes
      if (pipes.length === 0){
        spawnPipe(0);
        spawnPipe(240);
      }
    }

    function die(){
      if (dead) return;
      running = false;
      dead = true;
      statusEl.textContent = "Game Over";

      if(score > best){
        best = score;
        localStorage.setItem("bestSpaceRunner", String(best));
        bestEl.textContent = best;
      }
    }

    function flap(){
      if (!running && !dead) start();
      if (dead) { reset(); start(); }
      ship.vy = jumpV;
    }

    function spawnPipe(extraX=0){
      const gap = Math.max(150, 210 - score*2);
      const w = 64;
      const margin = 46;

      const topH = Math.floor(margin + Math.random() * (H - gap - margin*2));
      const x = W + 80 + extraX;

      pipes.push({ x, w, topH, gap, passed:false });
    }

    function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
      const nx = Math.max(rx, Math.min(cx, rx+rw));
      const ny = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx - nx;
      const dy = cy - ny;
      return (dx*dx + dy*dy) <= r*r;
    }

    function drawBackground(){
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(0,0,W,H);

      const g = ctx.createRadialGradient(W*0.55,H*0.22,0,W*0.55,H*0.22,Math.max(W,H)*0.85);
      g.addColorStop(0,"rgba(60,130,255,0.16)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
    }

    function drawPipe(p){
      const x=p.x, w=p.w;
      const botY = p.topH + p.gap;

      const grad = ctx.createLinearGradient(x,0,x+w,0);
      grad.addColorStop(0, "rgba(130,190,255,0.22)");
      grad.addColorStop(0.5, "rgba(255,255,255,0.12)");
      grad.addColorStop(1, "rgba(130,190,255,0.18)");
      ctx.fillStyle = grad;

      ctx.fillRect(x, 0, w, p.topH);
      ctx.fillRect(x, botY, w, H - botY);

      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x+0.5, 0+0.5, w-1, p.topH-1);
      ctx.strokeRect(x+0.5, botY+0.5, w-1, (H-botY)-1);
    }

    function drawShip(){
      ctx.save();
      ctx.translate(ship.x, ship.y);
      const tilt = Math.max(-0.7, Math.min(0.7, ship.vy / 700));
      ctx.rotate(tilt);

      ctx.beginPath();
      ctx.fillStyle = "rgba(80,140,255,0.20)";
      ctx.arc(0,0, ship.r+10, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.arc(0,0, ship.r, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = "rgba(60,130,255,0.55)";
      ctx.arc(ship.r*0.25, -ship.r*0.15, ship.r*0.45, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawText(){
      ctx.textAlign = "center";
      if(!running && !dead){
        ctx.fillStyle = "rgba(255,255,255,0.80)";
        ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("SPACE / CLICK / TAP — start & jump", W/2, H/2 - 6);
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Praskrisk pro tarpus. Kuo daugiau score — tuo sunkiau.", W/2, H/2 + 18);
      }
      if(dead){
        ctx.fillStyle = "rgba(255,255,255,0.86)";
        ctx.font = "950 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("GAME OVER", W/2, H/2 - 10);
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Paspausk Space / Click — restart", W/2, H/2 + 16);
      }
    }

    function update(dt){
      // dt seconds
      ship.vy += gravity * dt;
      ship.y += ship.vy * dt;

      if(ship.y - ship.r < 0) die();
      if(ship.y + ship.r > H) die();

      const speed = 240 + Math.min(220, score*10); // px/s
      for(const p of pipes){
        p.x -= speed * dt;

        if(!p.passed && p.x + p.w < ship.x){
          p.passed = true;
          score += 1;
          scoreEl.textContent = score;
        }

        const topHit = circleRectCollide(ship.x, ship.y, ship.r, p.x, 0, p.w, p.topH);
        const botY = p.topH + p.gap;
        const botHit = circleRectCollide(ship.x, ship.y, ship.r, p.x, botY, p.w, H - botY);
        if(topHit || botHit) die();
      }

      pipes = pipes.filter(p => p.x + p.w > -100);

      spawnAcc += dt;
      const spawnEvery = Math.max(1.1, 1.55 - score*0.02);
      if(spawnAcc > spawnEvery){
        spawnPipe(0);
        spawnAcc = 0;
      }
    }

    let last = 0;

    function frame(now){
      // ensure size
      if(!resizeGame()){
        requestAnimationFrame(frame);
        return;
      }

      if(!last) last = now;
      let dt = (now - last) / 1000;
      last = now;
      dt = Math.min(0.033, Math.max(0.0, dt)); // cap ~30fps step

      if(running && !dead){
        update(dt);
      }

      drawBackground();
      for(const p of pipes) drawPipe(p);
      drawShip();
      drawText();

      requestAnimationFrame(frame);
    }

    // Input
    window.addEventListener("keydown", (e)=>{
      if(e.code === "Space"){
        e.preventDefault();
        flap();
      }
    });

    canvas.addEventListener("mousedown", ()=> flap());
    canvas.addEventListener("touchstart", ()=> flap(), {passive:true});

    document.getElementById("start").addEventListener("click", ()=> { start(); flap(); });
    document.getElementById("restart").addEventListener("click", ()=> { reset(); start(); });

    window.addEventListener("resize", ()=> resizeGame());

    // init
    requestAnimationFrame(() => {
      resizeGame();
      reset();
      requestAnimationFrame(frame);
    });
  </script>
</body>
</html>
