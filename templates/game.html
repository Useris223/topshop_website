<!doctype html>
<html lang="lt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TopShop Deals – Click Rush</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <canvas id="snow" aria-hidden="true"></canvas>

  <main class="center" style="z-index:1;">
    <section class="card" style="padding:18px;">
      <div class="gamebar">
        <div class="stats">
          <div>Time: <b id="time">30</b>s</div>
          <div>Score: <b id="score">0</b></div>
          <div>Best: <b id="best">0</b></div>
        </div>

        <div class="actions">
          <button class="mini" id="start" type="button">Start</button>
          <button class="mini" id="restart" type="button">Restart</button>
          <a class="mini" href="/">Atgal</a>
        </div>
      </div>

      <canvas id="game" class="gamecanvas"></canvas>
      <div class="gamehint">
        Spausk <b>mėlynus</b> taikinius (+1). Venk <b>raudonų</b> bomb (−3). 30 sekundžių.
      </div>
    </section>
  </main>

  <script>
    // --------- simple snow bg (light) ----------
    const snow = document.getElementById("snow");
    const sctx = snow.getContext("2d");
    let SW=0, SH=0, sflakes=[];

    function sresize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      snow.width = Math.floor(window.innerWidth * dpr);
      snow.height = Math.floor(window.innerHeight * dpr);
      snow.style.width = window.innerWidth + "px";
      snow.style.height = window.innerHeight + "px";
      sctx.setTransform(dpr,0,0,dpr,0,0);
      SW = window.innerWidth; SH = window.innerHeight;
      const count = Math.floor((SW*SH)/18000);
      sflakes = Array.from({length:count}, ()=>({
        x: Math.random()*SW,
        y: Math.random()*SH,
        r: 0.8+Math.random()*2.0,
        vy: 0.5+Math.random()*1.1,
        a: 0.14+Math.random()*0.32
      }));
    }

    function sdraw(){
      const g = sctx.createLinearGradient(0,0,SW,SH);
      g.addColorStop(0,"#071c3e");
      g.addColorStop(1,"#02040c");
      sctx.fillStyle=g; sctx.fillRect(0,0,SW,SH);

      const glow = sctx.createRadialGradient(SW*0.18, SH*0.25, 0, SW*0.18, SH*0.25, Math.max(SW,SH)*0.6);
      glow.addColorStop(0, "rgba(60,130,255,0.16)");
      glow.addColorStop(1, "rgba(60,130,255,0)");
      sctx.fillStyle = glow;
      sctx.fillRect(0,0,SW,SH);

      for(const f of sflakes){
        f.y += f.vy;
        if(f.y>SH+10){ f.y = -10; f.x = Math.random()*SW; }
        sctx.beginPath();
        sctx.fillStyle = `rgba(255,255,255,${f.a})`;
        sctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        sctx.fill();
      }
      requestAnimationFrame(sdraw);
    }

    window.addEventListener("resize", sresize);
    sresize(); requestAnimationFrame(sdraw);

    // --------- Click Rush game ----------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");
    const bestEl = document.getElementById("best");

    let W=0, H=0;
    let running = false;
    let score = 0;
    let timeLeft = 30;
    let lastTick = 0;
    let spawnTimer = 0;

    let best = Number(localStorage.getItem("bestClickRush") || "0");
    bestEl.textContent = best;

    const targets = []; // {x,y,r,type,ttl,spawnAt}

    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      W = rect.width; H = rect.height;
    }
    window.addEventListener("resize", resize);

    function reset(){
      running = false;
      score = 0;
      timeLeft = 30;
      targets.length = 0;
      scoreEl.textContent = score;
      timeEl.textContent = timeLeft;
      spawnTimer = 0;
      lastTick = 0;
      drawFrame(0);
    }

    function rand(min,max){ return min + Math.random()*(max-min); }

    function spawn(){
      const isBomb = Math.random() < 0.22;
      const r = isBomb ? rand(18,26) : rand(18,30);

      const x = rand(r+14, W - r - 14);
      const y = rand(r+14, H - r - 14);

      // ttl shorter as time passes (harder)
      const base = isBomb ? rand(650, 950) : rand(750, 1150);
      const difficulty = 1 + (score / 40); // little ramp
      const ttl = Math.max(420, base / difficulty);

      targets.push({
        x, y, r,
        type: isBomb ? "bomb" : "good",
        ttl,
        born: performance.now()
      });
    }

    function hitTest(px, py, t){
      const dx = px - t.x, dy = py - t.y;
      return Math.hypot(dx,dy) <= t.r;
    }

    function onClick(px, py){
      if(!running) return;

      for(let i = targets.length-1; i>=0; i--){
        const t = targets[i];
        if(hitTest(px, py, t)){
          if(t.type === "good") score += 1;
          else score -= 3;

          targets.splice(i,1);
          scoreEl.textContent = score;
          // instant feedback: small burst
          burst(px, py, t.type);
          return;
        }
      }
    }

    // tiny particle burst
    const particles = []; // {x,y,vx,vy,life,kind}
    function burst(x,y,kind){
      const n = 10;
      for(let i=0;i<n;i++){
        particles.push({
          x, y,
          vx: rand(-1.6,1.6),
          vy: rand(-1.6,1.6),
          life: rand(240,420),
          born: performance.now(),
          kind
        });
      }
    }

    function drawBackground(){
      // subtle inner glow in game area
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "rgba(0,0,0,0.14)";
      ctx.fillRect(0,0,W,H);

      const g = ctx.createRadialGradient(W*0.5, H*0.2, 0, W*0.5, H*0.2, Math.max(W,H)*0.9);
      g.addColorStop(0,"rgba(60,130,255,0.14)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // faint vignette
      const v = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.25, W*0.5, H*0.55, Math.max(W,H)*0.75);
      v.addColorStop(0,"rgba(0,0,0,0)");
      v.addColorStop(1,"rgba(0,0,0,0.22)");
      ctx.fillStyle = v;
      ctx.fillRect(0,0,W,H);
    }

    function drawTarget(t, now){
      const age = now - t.born;
      const left = Math.max(0, t.ttl - age);
      const p = left / t.ttl; // 1 -> 0

      // slight pop animation at spawn
      const pop = Math.min(1, age / 120);
      const rr = t.r * (0.85 + 0.15*pop);

      // ring
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.strokeStyle = t.type === "good" ? "rgba(100,170,255,0.65)" : "rgba(255,90,90,0.62)";
      ctx.arc(t.x, t.y, rr+8, 0, Math.PI*2);
      ctx.stroke();

      // main circle
      ctx.beginPath();
      ctx.fillStyle = t.type === "good" ? "rgba(110,185,255,0.92)" : "rgba(255,90,90,0.92)";
      ctx.arc(t.x, t.y, rr, 0, Math.PI*2);
      ctx.fill();

      // shine
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.20)";
      ctx.arc(t.x - rr*0.35, t.y - rr*0.35, rr*0.35, 0, Math.PI*2);
      ctx.fill();

      // timer arc
      ctx.beginPath();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(255,255,255,0.28)";
      ctx.arc(t.x, t.y, rr+14, -Math.PI/2, (-Math.PI/2) + (Math.PI*2*p));
      ctx.stroke();
    }

    function drawParticles(now){
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        const age = now - p.born;
        if(age > p.life){ particles.splice(i,1); continue; }
        const k = 1 - (age/p.life);
        p.x += p.vx;
        p.y += p.vy;
        ctx.beginPath();
        ctx.fillStyle = p.kind === "good" ? `rgba(170,220,255,${0.45*k})` : `rgba(255,160,160,${0.45*k})`;
        ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawFrame(now){
      drawBackground();

      // remove expired targets (miss)
      for(let i=targets.length-1;i>=0;i--){
        const t = targets[i];
        if(now - t.born > t.ttl){
          targets.splice(i,1);
        }
      }

      for(const t of targets) drawTarget(t, now);
      drawParticles(now);

      // overlay instructions if not running
      if(!running){
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.font = "700 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.fillText("Spausk START ir rink taškus!", W/2, H/2 - 8);
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "500 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Mėlyni +1, raudoni −3. 30 sekundžių.", W/2, H/2 + 16);
      }
    }

    function loop(now){
      drawFrame(now);

      if(running){
        // spawn rhythm
        spawnTimer += (now - (lastTick || now));
        const spawnEvery = Math.max(280, 520 - Math.max(0, score)*2); // faster with score
        while(spawnTimer > spawnEvery){
          spawn();
          spawnTimer -= spawnEvery;
        }

        // timer
        if(!lastTick) lastTick = now;
        if(now - lastTick >= 1000){
          const steps = Math.floor((now - lastTick) / 1000);
          timeLeft = Math.max(0, timeLeft - steps);
          timeEl.textContent = timeLeft;
          lastTick += steps * 1000;

          if(timeLeft === 0){
            running = false;
            targets.length = 0;
            if(score > best){
              best = score;
              localStorage.setItem("bestClickRush", String(best));
              bestEl.textContent = best;
            }
          }
        }
      }

      requestAnimationFrame(loop);
    }

    function start(){
      if(running) return;
      reset();
      running = true;
      lastTick = performance.now();
      spawnTimer = 0;
      // initial few spawns
      for(let i=0;i<3;i++) spawn();
    }

    // pointer handling
    function getPos(ev){
      const rect = canvas.getBoundingClientRect();
      if(ev.touches && ev.touches[0]){
        return { x: ev.touches[0].clientX - rect.left, y: ev.touches[0].clientY - rect.top };
      }
      return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    }

    canvas.addEventListener("click", (e)=> {
      const rect = canvas.getBoundingClientRect();
      onClick(e.clientX - rect.left, e.clientY - rect.top);
    });

    canvas.addEventListener("touchstart", (e)=> {
      const p = getPos(e);
      onClick(p.x, p.y);
    }, {passive:true});

    document.getElementById("start").addEventListener("click", start);
    document.getElementById("restart").addEventListener("click", reset);

    resize();
    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
