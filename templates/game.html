<!doctype html>
<html lang="lt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TopShop Deals – Space Runner</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

  <style>
    /* Game page tweaks (keeps your global style.css look) */
    body{ overflow:hidden; }
    .hud{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
      padding: 10px 6px 12px;
      flex-wrap: wrap;
      color: rgba(255,255,255,.80);
      font-size: 14px;
    }
    .hud b{ color: rgba(255,255,255,.96); }
    .hud .left{ display:flex; gap: 16px; flex-wrap: wrap; align-items:center; }
    .hud .right{ display:flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    .mini{
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color: rgba(255,255,255,.92);
      text-decoration:none;
      font-weight: 900;
      cursor:pointer;
    }
    .mini:hover{ filter: brightness(1.10); }
    #game{
      width: 100%;
      height: min(600px, 72vh);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      display:block;
    }
    .hint{
      margin-top: 10px;
      color: rgba(255,255,255,.62);
      font-size: 12px;
      text-align:left;
    }
  </style>
</head>
<body>
  <!-- same background vibe -->
  <canvas id="snow" aria-hidden="true"></canvas>

  <main class="center" style="z-index:1;">
    <section class="card" style="padding:18px; text-align:left;">
      <div class="hud">
        <div class="left">
          <div>Score: <b id="score">0</b></div>
          <div>Best: <b id="best">0</b></div>
          <div>Status: <b id="status">Ready</b></div>
        </div>
        <div class="right">
          <button class="mini" id="start" type="button">Start</button>
          <button class="mini" id="restart" type="button">Restart</button>
          <a class="mini" href="/">Atgal</a>
        </div>
      </div>

      <canvas id="game"></canvas>
      <div class="hint">
        Valdymas: <b>Space</b> / <b>Click</b> / <b>Tap</b> — “šoktelėk” į viršų. Skrisk pro tarpus, neliesk sienų.
      </div>
    </section>
  </main>

  <script>
    // ---------- Background (light snow, same look) ----------
    const snow = document.getElementById("snow");
    const sctx = snow.getContext("2d");
    let SW=0, SH=0, sflakes=[];

    function sresize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      snow.width = Math.floor(window.innerWidth * dpr);
      snow.height = Math.floor(window.innerHeight * dpr);
      snow.style.width = window.innerWidth + "px";
      snow.style.height = window.innerHeight + "px";
      sctx.setTransform(dpr,0,0,dpr,0,0);
      SW = window.innerWidth; SH = window.innerHeight;
      const count = Math.floor((SW*SH)/18000);
      sflakes = Array.from({length:count}, ()=>({
        x: Math.random()*SW,
        y: Math.random()*SH,
        r: 0.8+Math.random()*2.0,
        vy: 0.5+Math.random()*1.1,
        a: 0.14+Math.random()*0.32
      }));
    }

    function sdraw(){
      const g = sctx.createLinearGradient(0,0,SW,SH);
      g.addColorStop(0,"#071c3e");
      g.addColorStop(1,"#02040c");
      sctx.fillStyle=g; sctx.fillRect(0,0,SW,SH);

      const glow = sctx.createRadialGradient(SW*0.18, SH*0.25, 0, SW*0.18, SH*0.25, Math.max(SW,SH)*0.6);
      glow.addColorStop(0, "rgba(60,130,255,0.16)");
      glow.addColorStop(1, "rgba(60,130,255,0)");
      sctx.fillStyle = glow;
      sctx.fillRect(0,0,SW,SH);

      for(const f of sflakes){
        f.y += f.vy;
        if(f.y>SH+10){ f.y = -10; f.x = Math.random()*SW; }
        sctx.beginPath();
        sctx.fillStyle = `rgba(255,255,255,${f.a})`;
        sctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        sctx.fill();
      }
      requestAnimationFrame(sdraw);
    }

    window.addEventListener("resize", sresize);
    sresize(); requestAnimationFrame(sdraw);

    // ---------- Space Runner game ----------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const statusEl = document.getElementById("status");

    let W=0, H=0, dpr=1;

    // Game state
    let running = false;
    let gameOver = false;

    let score = 0;
    let best = Number(localStorage.getItem("bestSpaceRunner") || "0");
    bestEl.textContent = best;

    // Player (ship)
    const ship = {
      x: 0, y: 0,
      r: 14,
      vy: 0
    };

    // Physics
    const gravity = 0.55;
    const jump = -8.6;

    // Obstacles
    let pipes = [];
    let spawnT = 0;

    function resize(){
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      W = rect.width; H = rect.height;

      ship.x = W * 0.28;
      if (!ship.y) ship.y = H * 0.5;
    }
    window.addEventListener("resize", resize);

    function reset(){
      running = false;
      gameOver = false;
      score = 0;
      pipes = [];
      spawnT = 0;
      ship.y = H * 0.5;
      ship.vy = 0;
      scoreEl.textContent = score;
      statusEl.textContent = "Ready";
      draw(performance.now());
    }

    function start(){
      if (running) return;
      running = true;
      gameOver = false;
      statusEl.textContent = "Go!";
      if (pipes.length === 0) {
        for (let i=0;i<2;i++) spawnPipe(i*220);
      }
    }

    function die(){
      running = false;
      gameOver = true;
      statusEl.textContent = "Game Over";
      if(score > best){
        best = score;
        localStorage.setItem("bestSpaceRunner", String(best));
        bestEl.textContent = best;
      }
    }

    function flap(){
      if (!running && !gameOver) start();
      if (gameOver) { reset(); start(); }
      ship.vy = jump;
    }

    function spawnPipe(extraX=0){
      const gap = Math.max(140, 185 - score*2);          // harder with score
      const pipeW = 62;
      const margin = 42;

      const topH = Math.floor(margin + Math.random() * (H - gap - margin*2));
      const x = W + 80 + extraX;

      pipes.push({
        x, w: pipeW,
        topH,
        gap,
        passed: false
      });
    }

    function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
      const nx = Math.max(rx, Math.min(cx, rx+rw));
      const ny = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx - nx;
      const dy = cy - ny;
      return (dx*dx + dy*dy) <= r*r;
    }

    function drawBackground(){
      // inner game glow
      ctx.clearRect(0,0,W,H);

      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(0,0,W,H);

      const g = ctx.createRadialGradient(W*0.55,H*0.22,0,W*0.55,H*0.22,Math.max(W,H)*0.85);
      g.addColorStop(0,"rgba(60,130,255,0.16)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // subtle stars
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      for(let i=0;i<30;i++){
        const x = (i*97) % W;
        const y = (i*53) % H;
        ctx.fillRect(x,y,2,2);
      }
    }

    function drawShip(){
      // ship body
      ctx.save();
      ctx.translate(ship.x, ship.y);

      const tilt = Math.max(-0.7, Math.min(0.7, ship.vy / 10));
      ctx.rotate(tilt);

      // glow
      ctx.beginPath();
      ctx.fillStyle = "rgba(80,140,255,0.20)";
      ctx.arc(0,0, ship.r+10, 0, Math.PI*2);
      ctx.fill();

      // main circle
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.arc(0,0, ship.r, 0, Math.PI*2);
      ctx.fill();

      // window
      ctx.beginPath();
      ctx.fillStyle = "rgba(60,130,255,0.55)";
      ctx.arc(ship.r*0.25, -ship.r*0.15, ship.r*0.45, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function drawPipe(p){
      // nice gradient pipe
      const x = p.x;
      const w = p.w;

      // top rect
      const topRect = {x, y:0, w, h:p.topH};
      const botY = p.topH + p.gap;
      const botRect = {x, y:botY, w, h: H - botY};

      const grad = ctx.createLinearGradient(x,0,x+w,0);
      grad.addColorStop(0, "rgba(130,190,255,0.22)");
      grad.addColorStop(0.5, "rgba(255,255,255,0.12)");
      grad.addColorStop(1, "rgba(130,190,255,0.18)");

      ctx.fillStyle = grad;

      // top
      ctx.fillRect(topRect.x, topRect.y, topRect.w, topRect.h);
      // bottom
      ctx.fillRect(botRect.x, botRect.y, botRect.w, botRect.h);

      // edges
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      ctx.strokeRect(topRect.x+0.5, topRect.y+0.5, topRect.w-1, topRect.h-1);
      ctx.strokeRect(botRect.x+0.5, botRect.y+0.5, botRect.w-1, botRect.h-1);

      // gap glow
      ctx.fillStyle = "rgba(60,130,255,0.08)";
      ctx.fillRect(x, p.topH, w, p.gap);
    }

    function drawOverlayText(){
      if(!running && !gameOver){
        ctx.fillStyle = "rgba(255,255,255,0.80)";
        ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.fillText("SPACE / CLICK / TAP — start & jump", W/2, H/2 - 6);
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "600 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Praskrisk pro tarpus. Kuo daugiau score — tuo sunkiau.", W/2, H/2 + 18);
      }
      if(gameOver){
        ctx.fillStyle = "rgba(255,255,255,0.86)";
        ctx.font = "950 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", W/2, H/2 - 10);
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Paspausk Space / Click — restart", W/2, H/2 + 16);
      }
    }

    let last = 0;

    function update(dt){
      // ship physics
      ship.vy += gravity;
      ship.y += ship.vy;

      // bounds
      if(ship.y - ship.r < 0) die();
      if(ship.y + ship.r > H) die();

      // pipes move
      const speed = 3.0 + Math.min(3.0, score/12); // gets faster
      for(const p of pipes){
        p.x -= speed;

        // scoring
        if(!p.passed && p.x + p.w < ship.x){
          p.passed = true;
          score += 1;
          scoreEl.textContent = score;
        }

        // collision with top and bottom pipes
        const topHit = circleRectCollide(ship.x, ship.y, ship.r, p.x, 0, p.w, p.topH);
        const botY = p.topH + p.gap;
        const botHit = circleRectCollide(ship.x, ship.y, ship.r, p.x, botY, p.w, H - botY);
        if(topHit || botHit) die();
      }

      // remove offscreen
      pipes = pipes.filter(p => p.x + p.w > -80);

      // spawn
      spawnT += dt;
      const spawnEvery = Math.max(1150, 1550 - score*20);
      if(spawnT > spawnEvery){
        spawnPipe(0);
        spawnT = 0;
      }
    }

    function draw(now){
      drawBackground();

      // pipes
      for(const p of pipes) drawPipe(p);

      // ship
      drawShip();

      // overlay texts
      drawOverlayText();

      requestAnimationFrame(loop);
    }

    function loop(now){
      if(!last) last = now;
      const dt = Math.min(40, now - last);
      last = now;

      if(running && !gameOver){
        update(dt);
      }

      draw(now);
    }

    // Input
    window.addEventListener("keydown", (e)=>{
      if(e.code === "Space"){
        e.preventDefault();
        flap();
      }
    });

    canvas.addEventListener("mousedown", ()=> flap());
    canvas.addEventListener("touchstart", ()=> flap(), {passive:true});

    document.getElementById("start").addEventListener("click", ()=> { start(); flap(); });
    document.getElementById("restart").addEventListener("click", ()=> { reset(); start(); });

    resize();
    reset();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
